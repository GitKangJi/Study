11장 조합 탐색
==============

## 01. 도입
#### &nbsp;지금까지 다룬 동적 계획법이나 분할 정복 등의 디자인 패러다임은 적절히 적용될 때는 매우 유용하지만, 모든 문제에 적용할 수 없다. 대개 답을 만드는 과정을 여러 개의 선택으로 나눈 뒤, 재귀 호출을 이용해 각각의 선택지를 채워가는 형태로 구현되곤 한다. 대부분 문제에서 탐색 공간의 크기는 문제의 규모에 따라 기하급수적으로 증가한다. 완전 탐색을 포함해, 이렇게 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아 내는 알고리즘들을 조합 탐색(Combinatorial Search)이라고 부른다. 조합 탐색에는 다양한 최적화 기법이 있으며, 이들은 접근 방법은 다르지만 모두 기본적으로 모두 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 만들어 봐야 할 답의 수를 줄이는 것을 목표로 한다.

## 02. 조합 탐색 기법들
#### &nbsp;여행하는 외원판 문제를 푸는 완전 탐색 알고리즘에 이 기법들을 적용하면서 변화하는 수행 속도를 관찰해 본다.

* ### 조합 탐색 뼈대의 구현
#### &nbsp;n이 16만 돼도 완전 탐색은 시간 초과(750시간)로 작동하지 않는다.

* ### 최적해보다 나빠지면 그만두기
#### &nbsp;현재 상태의 답이 지금까지 구한 최적해와 같거나 더 나쁠 떄 탐색을 중단한다.

* ### 간단한 휴리스틱을 이용한 가지치기
#### &nbps;휴리스틱을 이용해 답의 남은 부분을 어림짐작하는 가지치기를 이요하면 좀더 똑똑하게 가지치기를 할 수 있다. 휴리스틱을 이용한 가지치기는 남은 조각들을 푸는 최적해를 찾기는 오래 걸리더라도, 이 값을 적당히 어림짐작하기는 훨씬 빠르게 할 수 있다는 점을 이용해 가지치기를 수행한다.

* ### 휴리스틱 함수 작성하기
#### &nbsp;휴리스틱 함수를 만드는 좋은 방법 중 하나는 문제의 제약 조건을 일부 없앤 더 단순한 형태의 문제를 푸는 것이다.

* ### 단순한 휴리스틱 함수의 구현
#### &nbsp;아직 방문하지 않은 도시들에 대해 인접한 간선 중 가장 짧은 간선의 길이를 더한다.

* ### 가까운 도시부터 방문하기
#### &nbsp;도시를 번호 순서대로 방문하는 대신, 더 가까운 것부터 방문하면 좋은 답을 더 빨리 찾아낼 수 있는 경우가 있다.

* ### 지나온 경로를 이용한 가지치기
#### &nbsp;지금까지 만든 경로가 시작 상태에서 현재 상태까지 도달하는 최적해가 아니라고 하면 탐색을 계속할 이유가 없다.

* ### MST휴리스틱을 이용한 가지치기의 구현
#### &nbsp;최소 스패닝 트리를 이용한다.

* ### 마지막 단계 메모이제이션하기
#### &nbsp;조합 탐색 과정에서 같은 상태를 두 번 이상 맞닥뜨리는 것은 흔하다. 이런 비효율을 메모이제이션으로 제거한다.

## 03. 문제: 게임판 덮기 2(문제 ID: BOARDCOVER2, 난이도: 하)
#### &nbsp;H×W 크기의 게임판과 한 가지 모양의 블록이 여러 개 있습니다. 게임판에 가능한 많은 블록을 올려놓고 싶은데, 게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있으며 이 중에서 흰 칸에만 블록을 올려놓을 수 있습니다. 이때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 격자에 어긋나게 덮거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 됩니다. 위 그림은 예제 게임판과 L 자 모양의 블록으로 이 게임판을 덮는 방법을 보여줍니다. 게임판에는 15개의 흰 칸이 있고, 한 블록은 네 칸을 차지하기 때문에 그림과 같이 최대 세 개의 블록을 올려놓을 수 있지요. 게임판과 블록의 모양이 주어질 때 최대 몇 개의 블록을 올려놓을 수 있는지 판단하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 T (T≤100)가 주어집니다. 각 테스트 케이스의 첫 줄에는 게임판의 크기 H, W (1≤H, W≤10), 그리고 블록의 모양을 나타내는 격자의 크기 R, C (1≤R, C≤10)가 주어집니다. 다음 H줄에는 각각 W 글자의 문자열로 게임판의 정보가 주어집니다. 문자열의 각 글자는 게임판의 한 칸을 나타내며, #은 검은 칸, 마침표는 흰 칸을 의미합니다. 다음 R줄에는 각 C 글자의 문자열로 블록의 모양이 주어집니다. 이 문자열에서 #은 블록의 일부, 마침표는 빈 칸을 나타냅니다. 각 게임판에는 최대 50개의 흰 칸이 있으며, 각 블록은 3개 이상 10개 이하의 칸들로 구성됩니다. 변을 맞대고 있는 두 변이 서로 연결되어 있다고 할 때, 블록을 구성하는 모든 칸들은 서로 직접적 혹은 간접적으로 연결되어 있습니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 게임판에 놓을 수 있는 최대의 블록 수를 출력합니다.

* ### 개인적 풀이
#### &nbsp;