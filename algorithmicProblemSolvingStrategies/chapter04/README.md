4장 알고리즘의 시간 복잡도 분석
=============================

## 01. 도입
#### &nbsp;더 빠른 알고리즘을 만들기 위해서 가장 먼저 해야할 일은 알고리즘의 속도를 어떻게 측정할지를 정하는 것이다.

* ### 반복문이 지배한다
#### &nbsp;한가지 항목이 전체의 대소를 좌지우지하는 것을 지배한다(dominate)고 표현 한다. 알고리즘의 수행 시간을 지배하는 것은 반복문 이다. 따라서 우리는 알고리즘의 수행 시간을 반복문이 수행되는 횟수로 측정한다.

## 02. 선형시간 알고리즘

* ### 다이어트 현황 파악: 이동 평균 계산하기
#### &nbsp;이동 평균(Moving average)는 시간에 따라 변화하는 값들을 관찰할 때 유요하게 사용할 수 있는 통계적 기준이다. M 이동 평균은 마지막 M개의 관찰 값의 평균으로 정의 된다. 따라서 새 관찰 값이 나오면 이동 평균은 새 관찰 값을 포함하도록 바뀐다. 다음은 N개의 측정치가 주어질 때 매달 M달 간의 이동 평균을 계산 하는 프로그램이다.
```c++
vector<double> movingAverage1(const vector<double>& A, int M) {
  vector<double> ret;
  int N = A.size();

  for(int i = M - 1; i < N; ++i) {
    double partialSum = 0;
    for(int j = 0; j < M; ++j)
      partialSum += A[i-j];
    ret.push_back(partialSum / M);
  }
  return ret;
}
```
#### j를 사용하는 반복문은 항상 M번 실행되고 i를 사용하는 반복문은 N - M + 1번 실행되니, 전체 반복문은 N * M - M^2 + M 번 반복 된다. 이때 측정치가 M개는 돼야 이동 평균을 계산할 수 있다. 이떄 M-1의 이동 평균과 M의 이동 평균의 계산에 사용되는 값들은 0과 M일때를 제외 하면 전부 겹치게 된다. 그러면 일일이 합을 구하지 않고 M-1의 합에서 0일때 값을 빼고, M일때의 값을 더하면 M일때의 합이 나온다. 이런 구현은 다음과 같은 코드로 할 수 있다.
```c++
vector<double> movingAverage2(const vector<double>& A, int M) {
  vector<double> ret;
  int N = A.size();
  double partialSum = 0;
  
  for(int i = 0; i < M - 1; ++i)
    partialSum += A[i];
  for(int i = M-1; i < N; ++i) {
    partialSum += A[i];
    ret.push_back(partialSum / M);
    partialSum -= A[i -M + 1];
  }
  return ret;
}
```
#### 이와 같은 구현으로 수행 시간은 N에 정비례한다. 입력의 크기에 대비해 걸리는 시간을 그래프로 그려보면 정확히 직선이 된다. 때문에 이런 알고리즘을 선형 시간(Linear time) 알고리즘이라고 부른다.

## 03. 선형 이하 시간 알고리즘

* ### 성형 전 사진 찾기
#### 사진 10만장이 있을 때 언제 성형을 했는지 알고 싶으면 10만장을 다 보는 것 보다 5만번째 사진을 보고 성형을 했으면 2.5만번째 사진을 보고 안했으면 7.5만번째 사진을 보면서 계속 중간 값을 보는 것으로 17번 정도면 알아낼 수 있다. 이때 봐야 하는 사진의 장수를 N에 대해 표현하면 어떻게 될까? 매번 절반씩 나누니 밑이 2인 로그 함수를 사용하면 된다.(lg를 지수가 2인 log라 정의 한다) 따라서 확인해야 하는 사진의 수는 대략 lgN이 된다. 이와 같이 입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘들을 선형 이하 시간(Sublinear time) 알고리즘이라고 부른다.

* ### 이진 탐색
#### 방금 전 예제에서 사용한 알고리즘을 이진 탐색(binary search) 이라고 부른다. 하지만 정렬된 배열일때 사용 가능하다.

* ### 구현
#### 간단한 아이디어와는 달리 이진 탐색을 정확하게 구현하긴는 매우 까다롭다.
> 이진 탐색을 이용해 많은 시간초과 나는 문제를 푼 경험이 있다. 항상 구현은 어렵지만 실행시간은 엄청나게 줄일 수 있다.

## 04. 지수 시간 알고리즘

* ### 다항 시간 알고리즘
#### 