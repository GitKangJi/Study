8장 동적 계획법
==============

## 01. 도입
#### &nbsp;동적 계획법은 프로그래밍 대회 문제에서 가장 자주 출현하는 디자인 패러다임 중 하나이다. 동적 계획법(Dynamic programming)이라는 말은 최적화 문제를 연구하는 수학 이론에서 왔으면, 우리가 전산학 전반에서 일반적으로 사용하는 동적(dynamic), 혹은 프로그래밍(programming)이란 단어와는 아무런 관련이 없다. 따라서 dynamic programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법이다.

* ### 중복되는 부분 문제
#### &nbsp;동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있다. 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산 하고 계산 결과를 재활용함으로써 속도의 향상을 불러온다. 그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다. 나눠진 각 문제들이 같은 부분 문제에 의존을 할 때, 단순하게 재귀 호출을 동해 각 문제를 해결하면 중복 계산이 많아진다. 계산의 중복 횟수는 분할이 깊이가 깊어질 수록 지수적으로 증가하게 된다. 이 현상을 조합 폭발(combination explosion)이라고 부른다. 이런 문제를 해결하기 위해 고안된 알고리즘 설계 기법이 동적 계획법이다. 가장 유명한 예 중 하나는 이항 계수(binomial coefficient)의 계산이다. bino(n, r)을 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것으로 한다.
```c++
bino(n, r) = bino(n - 1, r - 1) + bino(n - 1, r);
```
#### 위와 같은 점화식이 성립한다.
```c++
int bino(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  return bino(n - 1, r - 1) + bino(n - 1, r);
}
```
#### 위 코드는 재귀 호출을 이용해서 bino를 구현한 것이다. 이때 계산하는 과정에서 많은 중복이 일어나며, 숫자가 커질수록 함수 호출 횟수는 기하 급수적으로 늘어난다. 따라서 cache 배열을 만들어서 각 입력에 대한 반환 값을 저장한다. 한번 계산한 값을 저장해 뒀다 재활용 하는 기법을 메모이제이션(memoization)이라고 부른다.
```c++
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
}
```
#### 이렇게 하면 함수 호출 횟수가 엄청나게 감소한다.

* ### 메모이제이션을 적용할 수 있는 경우
#### &nbsp;프로그래밍에서의 함수는 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수 많은 입력에 의해 작동하기 때문에 입력이 똑같다고 매번 출력이 같은 것은 아니다. 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들에만 적용할 수 있다.

* ### 메모이제이션 구현 패턴
```c++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### 위와 같은 함수를 다음과 같은 패턴으로 바꾼다.
```c++
// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아는 정수
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리한다.
  if(...) return ...;
  // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if(ret != -1) return ret;
  // 여기에서 답을 계산한다.
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache 배열을 초기화 시킨다
  memset(cache, -1, sizeof(cache));
}
```
#### 이런 일관적인 패턴은 디버깅을 도와준다.

* ### 메모이제이션의 시간 복잡도 분석
#### &nbsp;간단하게 다음과 같은 식을 이용해서 시간 복잡도를 계산할 수 있다.
```c++
(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```
#### 이 식은 항상 정확하지는 않지만 상한을 간단히 계산할 수 있는 방법이다.

* ### 예제: 외발 뛰기(문제 ID: JUMPGAME, 난이도: 하)
#### &nbsp;땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다. 균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다. 게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.

* ### 개인적 풀이
#### &nbsp;메모이제이션 기법을 사용하기 위해서 check[101][101]배열을 생성하고 각 좌표에서 출발해 본적이 있으면 1을 넣고 아니면 -1을 넣는다. 처음에 0, 0에서 시작하고 재귀적으로 갈수 있는 좌표 모두를 가본다. 이렇게 n, n에 도달 했는지를 검사한다.
```c++
int n;
int board[101][101];
int check[101][101];
checkBoard(int x, int y) {
  // 기저 사례 끝부분에 도착하면 2를 반환하고 접근할 수 없는 인덱스에 접근했을 때 -1을 반환
  if(x == n && y == n) return 2;
  if(x > n || y > n) return -1;

  // 특정 좌표에서 출발해 본적이 있는지 검사
  int ret = check[x][y];
  if(ret == 1) return ret;

  int& move = board[101][101];
  ret = checkBoard(x + move, y) || checkBoard(x, y + move);

  return ret;
}
```
#### 이런 방향성을 가지고 풀게 되면 될 것 같다.

* ### 재귀 호출에서 시작하기
#### &nbsp;동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 모든 경로를 하나씩 만들어 봄녀서 마지막 칸에 도달할 수 있는지를 검사한다.
```c++
int n, board[100][100];
bool jump(int y, int x) {
  // 기저 사례: 게임판 밖을 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n - 1 && x == n - 1) return true;
  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

* ### 메모이제이션 적용하기
#### &nbsp;완전 탐색을 사용할 때 흔히 가장 문제가 되는 것은 원하는 전체 답의 개수는 무지막지하게 많은 경우다. 다음은 메모이제이션을 적용해서 중복을 없애는 코드다.
```c++
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
  // 기저 사례
  if(y >= n || x >= n) return 0;
  if(y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if(ret != -1) return ret;
  int jumpSize = board[y][x];
  return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```

* ### 내가 짠 코드와 비교해 보기
#### &nbsp;아이디어는 똑같았지만 아직 언어에 대한 이해와 문법 능력이 부족해 오류가 나는 코드를 만들었다. 포인터와 언어에 대한 이해가 조금더 필요하다.


* ### 다른 해법
#### &nbsp;이 문제는 사실 크래프로 모델링해보면 아주 간단한 도달 가능성 문제가 된다.

* ### 동적 계획법 레시피
#### &nbsp;1. 주어진 문제를 완전 탐색을 이용해 해결한다. 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

* ### 다른 구현 방법에 관하여
#### &nbsp;재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현할 수 있다. 이런 방법을 반복적 동적 계획법이라고 부른다.

## 02. 문제: 와일드카드(문제 ID: WILDCARD, 난이도: 중)
#### &nbsp;와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다. 와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다. 예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다. 와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

* ### 개인적 풀이
#### &nbsp;이 문제에 대해서는 풀이법이 잘 떠오르지 않는다.

## 03. 풀이: 와일드카드

* ### *가 문제로다
#### &nbsp;이 문제를 어렵게 만드는 것은 *가 몇 글자에 대응되어야 하는지를 미리 알 수 없다는 점이다. 주어진 패턴이 m개의 *을 포함한다고 한다. 이 패턴을 *가 나타날 때마다 쪼개면 이 패턴이 문자열에 대응되는지 확인하는 문제를 m+1조각으로 나눌 수 있다. 예를 들어 t*l?*o*r?ng*s는 t*, l?*, o*, r?ng*, s로 나눌 수 있다. 이렇게 쪼갠 문자열이 대응되는지 여부를 재귀 호출로 파악할 수 있다. 물론 실제로 패턴을 쪼개지 않고도 이를 구현할 수 있다.
```c++
// 와일드카드 패턴 w가 문자열 s에 대응되는지 여부를 반환한다.
bool match(const string& w, const string& s) {
  // w[pos]와 s[pos]를 맞춰나간다.
  int pos = 0;
  while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos]))
    ++pos;
  // 더이상 대을할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 대응됨.
  if(pos == w.size())
    return pos == s.size();
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(w[pos] == '*')
    for(int skip = 0; pos + skip <= s.size(); ++skip)
      if(match(w.substr(pos + 1), s.substr(pos + skip)))
        return true;
  // 이 외의 경우에는 모두 대응되지 않는다.
  return false;
}
```

* ### 중복되는 부분 문제
#### &nbsp;위와 같은 방법은 *가 많을 수록 이 경우의 수는 늘어나서 오랜 시간이 걸린다. 예를 들어 123*abc*def*ghi이 패턴에는 '*'가 세 개 있는데 이때 def*ghi 부분이 123*...과 abc*...를 해결할 때 중복된다. 입력으로 주어질 수 있는 w와 s는 각각 최대 101개밖에 없다. 다음과 같이 메모이제이션을 사용해 중복 계산을 줄일 수 있다.
```c++
// -1은 아직 답이 계산되지 않았음을 의미한다.
// 1은 해당 입력들이 서로 대응됨을 의미한다.
// 0은 해당 입력들이 서로 대응되지 않음을 의미한다.
int cache[101][101];
// 패턴과 문자열
string W, S;
// 파일드카드 패턴 W[w..]가 문자열 S[s..]에 대응되는지 여부를 반환한다.
bool matchMemoized(int w, int s) {
  // 메모이제이션
  int& ret = cache[w][s];
  if(ret != -1) return ret;
  // W[w]와 S[s]를 맞춰나간다.
  while(s < S.size() && w < W.size() && (W[w] == '?' || W[w] == S[s])) {
    ++w;
    ++s;
  }
  // 더이상 대응할 수 없으면 왜 while문이 끝났는지 확인한다.
  // 2. 패턴 끝에 도달해서 끝난 경우: 문자열도 끝났어야 참
  if(w == W.size()) return ret = (s == S.size());
  // 4. *를 만나서 끝난 경우: *에 몇 글자를 대응해야 할지 재귀 호출하면서 확인한다.
  if(W[w] == '*')
    for(int skip = 0; skip + s <= S.size(); ++skip)
      if(matchMemoized(w + 1, s + skip))
        return ret = 1;
  // 3. 이 외의 경우에는 모두 대응되지 않는다.
  return ret = 0;
}
```

* ### 다른 분해 방법
#### &nbsp;다른 분해 방식을 사용하면 이 문제를 O(n^2)시간에 풀 수 있다.

## 04. 전통적 최적화 문제들
#### &nbsp;동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결이다. 최적화 문제에 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기보다 좀더 효율적으로 동적 계획법을 구현할 수 있다.

* ### 예제: 삼각형 위의 최대 경로(문제 ID: TRIANGLEPATH, 난이도: 하)
#### 6
#### 1 2
#### 3 7 4
#### &nbsp;위 형태와 같이 삼각형 모양으로 배치된 자연수들이 있습니다. 맨 위의 숫자에서 시작해, 한 번에 한 칸씩 아래로 내려가 맨 아래 줄로 내려가는 경로를 만들려고 합니다. 경로는 아래 줄로 내려갈 때마다 바로 아래 숫자, 혹은 오른쪽 아래 숫자로 내려갈 수 있습니다. 이 때 모든 경로 중 포함된 숫자의 최대 합을 찾는 프로그램을 작성하세요.

* ### 개인적 풀이
#### &nbsp;일단 완전 탐색을 통해서 아래로 갈 것인지 아니면 오른쪽 아래로 갈 것인지 찾아내면 될 것 같다.
```c++
int n;
int board[100][100];
int boardMaxSum[100][100];

int findMaxSum(int y, int x) {
  // 기저 사례: 삼각형이 아닌 부분을 참조하려 했을 때
  if(y >= n || x > y + 1 || y < 0 || x < 0) return 0;
  
  // x - 1값이 0 미만 일때
  if(x - 1 < 0) {
    // y - 1값이 0미만 일 때
    if(y - 1 < 0) {
      boardMaxSum[y][x] = board[y][x];
    } else {
      boardMaxSum[y][x] = board[y][x] + board[y - 1][x];
    }
  } else {
    // 특정 [y][x]에서의 최대 값은 [y - 1][x - 1]와 [y - 1][x]중 큰 값에 [y][x]값을 더 한 것이다.
    if(boardMaxSum[y - 1][x - 1] > boardMaxSum[y - 1][x]) {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x - 1];
    } else {
      boardMaxSum[y][x] += boardMaxSum[y - 1][x];
    }
  }

  // 아래로 이동
  findMaxSum(y + 1, x);
  // 오른쪽 아래로 이동
  findMaxSum(y + 1, x + 1);
};
```
> 이런식으로 재귀 호출을 하게 되면 계산 되지 않은 값을 참조하는 경우가 생기기 때문에 안된다.

* ### 완전 탐색으로 시작하기
#### &nbsp;재귀 호출을 하는데 현재 위치와 지금가지 만난 숫자들의 함을 전달한다. pathSum(y, x, sum)이 현재 위치가 (y, x)이고, 지금까지 만난 수의 합이 sum일 때, 이 결로를 맨 아래줄까지 연장해서 얻을 수 있는 최대 합을 반환한다.

* ### 무식하게 메모이제이션 적용하기
#### &nbsp;n개의 가로줄이 있으면 가능한 경로의 수는 2^(n - 1)이다. 이때 n이 100정도만 돼도 계산할 수 없다. 다음과 같은 코드를 보자.
```c++
// MAX_NUMBER: 한 칸에 들어갈 숫자의 최대치
int n, triangle[100][100];
int cache[100][100][MAX_NUMBER * 100 + 1];
// y, x 위치까지 내려오기 전에 만난 숫자들의 합이 sum일 때 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로를 반환한다.
int path1(int y, int x, int sum) {
  // 기저 사례: 맨 아래 줄까지 도달했을 경우
  if(y == n - 1) return sum + triangle[y][x];
  // 메모이제이션
  int& ret = cache[y][x][sum];
  if(ret != -1) return ret;
  sum += triangle[y][x];
  return ret = max(path1(y+1, x+1, sum), path1(y+1, x, sum));
}
```
#### 이 코드는 완전 탐색과 다를 바가 없다.

* ### 입력 걸러내기
#### &nbsp;재귀 함수의 입력을 다음과 같이 두 부류로 나눠본다.
#### 1. y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정한다. 이 두 입력이 정해지면 앞으로 우리가 만들 수 있는 경로들이 정해진다. 따라서 이들은 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들이다.
#### 2. 반면 sum은 지금가지 어떤 경로로 이 부분 문제에 도달했는지를 나타낸다. sum은 지금가지 풀었던 조각들에 대한 정보를 주는 입력이다.
#### path2(y, x)는 y, x에서 시작해서 맨 아래줄까지 내려가는 부분 경로의 최대합을 반환한다.
```c++
int n, triangle[100][100];
int cache2[100][100];
// (y, x) 위치부터 맨 아래줄까지 내려가면서 얻을 수 있는 최대 경로의 합을 반환한다.
int path2(int y, int x) {
  // 기저 사례
  if(y == n - 1) return triangle[y][x];
  //메모이제이션
  int& ret = cache2[y][x];
  if(ret != -1) return ret;
  return ret = max(path2(y + 1, x), path2(y + 1, x + 1)) + triangle[y][x];
}
```
#### 0, 0부터 내려가는 것이 아닌 마지막 줄부터 올라온다.

* ### 내가 짠 코드와 비교해보기
#### &nbsp;해야하는 방향성은 알겠지만 코드로 구현하는 것이 매우 힘들다. 지속적으로 틀린다. 책에 써져 있는 코드는 깔끔하게 잘 써져 있어서 좋은 듯 하다.

* ### 이론적 배경: 최적 부분 구조
#### &nbsp;최적화가 가능했던 이유는 sum이라는 정보가 (y, x)에서 맨 아래줄까지 내려가는 문제를 해결하는 데 아무 상관이 없다는 사실을 파악한 덕분이다. 지금 까지 어던 경로로 이 부분 문제에 도달했건 남은 부분 문제는 항상 최적으로 풀어도 상관 없다. 이것은 효율적인 동적 계획법 알고리즘을 적용하기 위해 아주 중요한 조건이다. 최적 부분 구조(Optimal substructure)이라고 불린다.

* ### 예제: 최대 증가 부분 수열(문제 ID: LIS, 난이도: 하)
#### &nbsp;어떤 정수 수열에서 0개 이상의 숫자를 지우면 이 수열의 부분 수열 (subsequence) 를 얻을 수 있다. 예를 들어 10 7 4 9 의 부분 수열에는 7 4 9, 10 4, 10 9 등이 있다. 단, 10 4 7 은 원래 수열의 순서와 다르므로 10 7 4 9 의 부분 수열이 아니다. 어떤 부분 수열이 순증가할 때 이 부분 수열을 증가 부분 수열 (increasing subsequence) 라고 한다. 주어진 수열의 증가 부분 수열 중 가장 긴 것의 길이를 계산하는 프로그램을 작성하라. 어떤 수열의 각 수가 이전의 수보다 클 때, 이 수열을 순증가 한다고 한다.

* ### 개인적 풀이
#### &nbsp;