8장 동적 계획법
==============

## 01. 도입
#### &nbps;동적 계획법은 프로그래밍 대회 문제에서 가장 자주 출현하는 디자인 패러다임 중 하나이다. 동적 계획법(Dynamic programming)이라는 말은 최적화 문제를 연구하는 수학 이론에서 왔으면, 우리가 전산학 전반에서 일반적으로 사용하는 동적(dynamic), 혹은 프로그래밍(programming)이란 단어와는 아무런 관련이 없다. 따라서 dynamic programming의 적절한 번역은 동적 프로그래밍이 아니라 동적 계획법이다.

* ### 중복되는 부분 문제
#### &nbps;동적 계획법은 큰 의미에서 분할 정복과 같은 접근 방식을 의미한다. 동적 계획법과 분할 정복의 차이가 발생하는 부분은 문제를 나누는 방식이다. 동적 계획법에서 어떤 부분 문제는 두 개 이상의 문제를 푸는데 사용될 수 있다. 이 문제의 답을 여러 번 계산하는 대신 한 번만 계산 하고 계산 결과를 재활용함으로써 속도의 향상을 불러온다. 그러기 위해서는 각 문제의 답을 메모리에 저장해 둘 필요가 있다. 이때 이미 계산한 값을 저장해 두는 메모리의 장소를 캐시(cache)라고 부르며, 두 번 이상 계산되는 부분 문제를 중복되는 부분 문제(overlapping subproblems)라고 부른다. 나눠진 각 문제들이 같은 부분 문제에 의존을 할 때, 단순하게 재귀 호출을 동해 각 문제를 해결하면 중복 계산이 많아진다. 계산의 중복 횟수는 분할이 깊이가 깊어질 수록 지수적으로 증가하게 된다. 이 현상을 조합 폭발(combination explosion)이라고 부른다. 이런 문제를 해결하기 위해 고안된 알고리즘 설계 기법이 동적 계획법이다. 가장 유명한 예 중 하나는 이항 계수(binomial coefficient)의 계산이다. bino(n, r)을 n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수를 나타내는 것으로 한다.
```c++
bino(n, r) = bino(n - 1, r - 1) + bino(n - 1, r);
```
#### 위와 같은 점화식이 성립한다.
```c++
int bino(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  return bino(n - 1, r - 1) + bino(n - 1, r);
}
```
#### 위 코드는 재귀 호출을 이용해서 bino를 구현한 것이다. 이때 계산하는 과정에서 많은 중복이 일어나며, 숫자가 커질수록 함수 호출 횟수는 기하 급수적으로 늘어난다. 따라서 cache 배열을 만들어서 각 입력에 대한 반환 값을 저장한다. 한번 계산한 값을 저장해 뒀다 재활용 하는 기법을 메모이제이션(memoization)이라고 부른다.
```c++
int cache[30][30];
int bino2(int n, int r) {
  // 기저 사례
  if(r == 0 || n == r) return 1;
  // -1이 아니라면 한 번 계산했던 값이니 곧장 반환
  if(cache[n][r] != -1)
    return cache[n][r];
  // 직접 계산한 뒤 배열에 저장
  return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
}
```
#### 이렇게 하면 함수 호출 횟수가 엄청나게 감소한다.

* ### 메모이제이션을 적용할 수 있는 경우
#### &nbsp;프로그래밍에서의 함수는 전역 변수, 입력 파일, 클래스의 멤버 변수 등 수 많은 입력에 의해 작동하기 때문에 입력이 똑같다고 매번 출력이 같은 것은 아니다. 입력이 고정되어 있을 때 그 결과가 항상 같은 함수들에만 적용할 수 있다.

* ### 메모이제이션 구현 패턴
```c++
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
#### 위와 같은 함수를 다음과 같은 패턴으로 바꾼다.
```c++
// 전부 -1로 초기화해 둔다
int cache[2500][2500];
// a와 b는 각각 [0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아는 정수
int someObscureFunction(int a, int b) {
  // 기저 사례를 처음에 처리한다.
  if(...) return ...;
  // (a, b)에 대한 답을 구한 적이 있으면 곧장 반환
  int& ret = cache[a][b];
  if(ret != -1) return ret;
  // 여기에서 답을 계산한다.
  ...
  return ret;
}

int main() {
  // memset()을 이용해 cache 배열을 초기화 시킨다
  memset(cache, -1, sizeof(cache));
}
```
#### 이런 일관적인 패턴은 디버깅을 도와준다.

* ### 메모이제이션의 시간 복잡도 분석
#### &nbsp;간단하게 다음과 같은 식을 이용해서 시간 복잡도를 계산할 수 있다.
```c++
(존재하는 부분 문제의 수) * (한 부분 문제를 풀 때 필요한 반복문의 수행 횟수)
```
#### 이 식은 항상 정확하지는 않지만 상한을 간단히 계산할 수 있는 방법이다.

* ### 예제: 외발 뛰기(문제 ID: JUMPGAME, 난이도: 하)
#### &nbsp;땅따먹기를 하다 질린 재하와 영훈이는 땅따먹기의 변종인 새로운 게임을 하기로 했습니다. 이 게임은 그림과 같이 n*n 크기의 격자에 각 1부터 9 사이의 정수를 쓴 상태로 시작합니다. 각 차례인 사람은 맨 왼쪽 윗 칸에서 시작해 외발로 뛰어서 오른쪽 아래 칸으로 내려가야 합니다. 이 때 각 칸에 적혀 있는 숫자만큼 오른쪽이나 아래 칸으로 움직일 수 있으며, 중간에 게임판 밖으로 벗어나면 안 됩니다. 균형을 잃어서 다른 발로 서거나 넘어져도 게임에서 집니다만, 재하와 영훈이는 젊고 활기차기 때문에 외발로 뛰어다니는 것은 아무것도 아닙니다. 다만 걱정되는 것은 주어진 게임판에 시작점에서 끝점으로 가는 방법이 존재하지 않을 수도 있다는 것입니다. 예를 들어 그림 (a)의 게임판에서는 사각형으로 표시된 칸들을 통해 끝에 도달할 수 있지만, 숫자가 하나 바뀐 그림 (b)에서는 그럴 수가 없습니다. 게임판이 주어질 때 왼쪽 위의 시작점에서 오른쪽 아래의 시작점에 도달할 수 있는 방법이 있는지 확인하는 프로그램을 작성하세요.

* ### 개인적 풀이
#### &nbsp;메모이제이션 기법을 사용하기 위해서 check[101][101]배열을 생성하고 각 좌표에서 출발해 본적이 있으면 1을 넣고 아니면 -1을 넣는다. 처음에 0, 0에서 시작하고 재귀적으로 갈수 있는 좌표 모두를 가본다. 이렇게 n, n에 도달 했는지를 검사한다.
```c++
int n;
int board[101][101];
int check[101][101];
checkBoard(int x, int y) {
  // 기저 사례 끝부분에 도착하면 2를 반환하고 접근할 수 없는 인덱스에 접근했을 때 -1을 반환
  if(x == n && y == n) return 2;
  if(x > n || y > n) return -1;

  // 특정 좌표에서 출발해 본적이 있는지 검사
  int ret = check[x][y];
  if(ret == 1) return ret;

  int& move = board[101][101];
  ret = checkBoard(x + move, y) || checkBoard(x, y + move);

  return ret;
}
```
#### 이런 방향성을 가지고 풀게 되면 될 것 같다.

* ### 재귀 호출에서 시작하기
#### &nbsp;동적 계획법 알고리즘을 만드는 첫 단계는 해당 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 모든 경로를 하나씩 만들어 봄녀서 마지막 칸에 도달할 수 있는지를 검사한다.
```c++
int n, board[100][100];
bool jump(int y, int x) {
  // 기저 사례: 게임판 밖을 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n - 1 && x == n - 1) return true;
  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

* ### 메모이제이션 적용하기
#### &nbps;완전 탐색을 사용할 때 흔히 가장 문제가 되는 것은 원하는 전체 답의 개수는 무지막지하게 많은 경우다. 다음은 메모이제이션을 적용해서 중복을 없애는 코드다.
```c++
int n, board[100][100];
int cache[100][100];
int jump2(int y, int x) {
  // 기저 사례
  if(y >= n || x >= n) return 0;
  if(y == n-1 && x == n-1) return 1;

  // 메모이제이션
  int& ret = cache[y][x];
  if(ret != -1) return ret;
  int jumpSize = board[y][x];
  return ret = (jump2(y + jumpSize, x) || jump2(y, x + jumpSize));
}
```

* ### 내가 짠 코드와 비교해 보기
#### &nbsp;아이디어는 똑같았지만 아직 언어에 대한 이해와 문법 능력이 부족해 오류가 나는 코드를 만들었다. 포인터와 언어에 대한 이해가 조금더 필요하다.


* ### 다른 해법
#### &nbsp;이 문제는 사실 크래프로 모델링해보면 아주 간단한 도달 가능성 문제가 된다.

* ### 동적 계획법 레시피
#### &nbsp;1. 주어진 문제를 완전 탐색을 이용해 해결한다. 2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

* ### 다른 구현 방법에 관하여
#### &nbsp;재귀 호출을 이용하지 않고도 동적 계획법 알고리즘을 구현할 수 있다. 이런 방법을 반복적 동적 계획법이라고 부른다.

## 02. 문제: 와일드카드(문제 ID: WILDCARD, 난이도: 중)
#### &nbsp;와일드카드는 다양한 운영체제에서 파일 이름의 일부만으로 파일 이름을 지정하는 방법이다. 와일드카드 문자열은 일반적인 파일명과 같지만, * 나 ? 와 같은 특수 문자를 포함한다. 와일드카드 문자열을 앞에서 한 글자씩 파일명과 비교해서, 모든 글자가 일치했을 때 해당 와일드카드 문자열이 파일명과 매치된다고 하자. 단, 와일드카드 문자열에 포함된 ? 는 어떤 글자와 비교해도 일치한다고 가정하며, * 는 0 글자 이상의 어떤 문자열에도 일치한다고 본다. 예를 들어 와일드 카드 he?p 는 파일명 help 에도, heap 에도 매치되지만, helpp 에는 매치되지 않는다. 와일드 카드 *p* 는 파일명 help 에도, papa 에도 매치되지만, hello 에는 매치되지 않는다. 와일드카드 문자열과 함께 파일명의 집합이 주어질 때, 그 중 매치되는 파일명들을 찾아내는 프로그램을 작성하시오.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1 <= C <= 10) 가 주어진다. 각 테스트 케이스의 첫 줄에는 와일드카드 문자열 W 가 주어지며, 그 다음 줄에는 파일명의 수 N (1 <= N <= 50) 이 주어진다. 그 후 N 줄에 하나씩 각 파일명이 주어진다. 파일명은 공백 없이 알파벳 대소문자와 숫자만으로 이루어져 있으며, 와일드카드는 그 외에 * 와 ? 를 가질 수 있다. 모든 문자열의 길이는 1 이상 100 이하이다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 주어진 와일드카드에 매치되는 파일들의 이름을 한 줄에 하나씩 아스키 코드 순서(숫자, 대문자, 소문자 순)대로 출력한다.

* ### 개인적 풀이
#### &nbsp;