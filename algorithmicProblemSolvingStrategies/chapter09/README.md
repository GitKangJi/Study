9장 동적 계획법 테크닉
================
## 01. 최적화 문제의 실제 답 계산하기

* ### 예제: 최대 증가 부분 수열 실제로 출력하기
#### &nbsp;LIS가 실제 어떤 원소들로 구성되는지는 알 수가 없다. LIS를 구성하는 원소를 찾으려면 어떻게 해야하나? 실제 답을 계산하기 위해서는 각 부분 문제마다 어떤 선택지를 택했을 때 최적해를 얻는지를 기록해 두고, 별도의 재귀 함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성해 내면 된다.
```c++
int n;
int cache[101], s[100], choices[101];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis4(int start) {
  int& ret = cache[start + 1];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  int bestNext = -1;
  for(int next = start + 1; next < n; ++next)
    if(start == -1 || S[start] < S[next]) {
      int cand = lis4(next) + 1;
      if(cand > ret) {
        ret = cand;
        bextNext = next;
      }
    }
  choices[start + 1] = bestNext;
  return ret;
}
// S[start]에서 시작하는 LIS를 seq에 저장한다.
void reconstruct(int start, vector<int>& seq) {
  if(start != -1) seq.push_back(S[start]);
  int next = choices[start + 1];
  if(next != -1) reconstruct(next, seq);
}
```

* ### 최적화 문제 답 계산하기 레시피
#### 01. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해둔다.
#### 02. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.

## 07. 문제: 여행 짐 싸기(문제 ID: PACKING, 난이도: 중)
#### &nbsp;여행을 떠나기 전날까지 절대 짐을 싸지 않는 버릇이 있는 재훈이는 오늘도 비행기 타기 전날에야 가방을 싸기 위해 자리에 앉았습니다. 비행기 규정상 재훈이는 캐리어를 하나만 가지고 갈 수 있는데, 아무래도 가져가고 싶은 물건들이 캐리어 안에 다 들어가지 않을 것 같습니다. 재훈이는 가져가고 싶은 각 물건들의 부피와 얼마나 필요한지를 나타내는 절박도를 조사해 다음과 같은 목록을 만들었습니다. 캐리어의 용량이 정해져 있기 때문에 가져갈 수 있는 물건들의 부피 합은 캐리어의 용량 w 이하여야 합니다. 이때 절박도를 최대화할 수 있는 물건들의 목록을 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 가져가고 싶은 물건의 수 N (1≤N≤100)과 캐리어의 용량 W (1≤W≤1000)가 주어집니다. 그 이후 N줄에 순서대로 각 물건의 정보가 주어집니다. 한 물건에 대한 정보는 물건의 이름, 부피, 절박도 순서대로 주어지며, 이름은 공백 없는 알파벳 대소문자 1글자 이상 20글자 이하의 문자열, 부피와 절박도는 1000 이하의 자연수입니다.

* ### 출력
#### &nbsp;각 테스트 케이스별 출력의 첫 줄에는 가져갈 수 있는 물건들의 최대 절박도 합과 가져갈 물건들의 개수를 출력합니다. 이후 한 줄에 하나씩 각 물건들의 이름을 출력합니다. 만약 절박도를 최대화하는 물건들의 조합이 여럿일 경우 아무 것이나 출력해도 좋습니다.

* ### 개인적 풀이
#### &nbsp;