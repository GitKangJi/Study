9장 동적 계획법 테크닉
================
## 01. 최적화 문제의 실제 답 계산하기

* ### 예제: 최대 증가 부분 수열 실제로 출력하기
#### &nbsp;LIS가 실제 어떤 원소들로 구성되는지는 알 수가 없다. LIS를 구성하는 원소를 찾으려면 어떻게 해야하나? 실제 답을 계산하기 위해서는 각 부분 문제마다 어떤 선택지를 택했을 때 최적해를 얻는지를 기록해 두고, 별도의 재귀 함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성해 내면 된다.
```c++
int n;
int cache[101], s[100], choices[101];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis4(int start) {
  int& ret = cache[start + 1];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  int bestNext = -1;
  for(int next = start + 1; next < n; ++next)
    if(start == -1 || S[start] < S[next]) {
      int cand = lis4(next) + 1;
      if(cand > ret) {
        ret = cand;
        bextNext = next;
      }
    }
  choices[start + 1] = bestNext;
  return ret;
}
// S[start]에서 시작하는 LIS를 seq에 저장한다.
void reconstruct(int start, vector<int>& seq) {
  if(start != -1) seq.push_back(S[start]);
  int next = choices[start + 1];
  if(next != -1) reconstruct(next, seq);
}
```

* ### 최적화 문제 답 계산하기 레시피
#### 01. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해둔다.
#### 02. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.

## 02. 문제: 여행 짐 싸기(문제 ID: PACKING, 난이도: 중)
#### &nbsp;여행을 떠나기 전날까지 절대 짐을 싸지 않는 버릇이 있는 재훈이는 오늘도 비행기 타기 전날에야 가방을 싸기 위해 자리에 앉았습니다. 비행기 규정상 재훈이는 캐리어를 하나만 가지고 갈 수 있는데, 아무래도 가져가고 싶은 물건들이 캐리어 안에 다 들어가지 않을 것 같습니다. 재훈이는 가져가고 싶은 각 물건들의 부피와 얼마나 필요한지를 나타내는 절박도를 조사해 다음과 같은 목록을 만들었습니다. 캐리어의 용량이 정해져 있기 때문에 가져갈 수 있는 물건들의 부피 합은 캐리어의 용량 w 이하여야 합니다. 이때 절박도를 최대화할 수 있는 물건들의 목록을 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 가져가고 싶은 물건의 수 N (1≤N≤100)과 캐리어의 용량 W (1≤W≤1000)가 주어집니다. 그 이후 N줄에 순서대로 각 물건의 정보가 주어집니다. 한 물건에 대한 정보는 물건의 이름, 부피, 절박도 순서대로 주어지며, 이름은 공백 없는 알파벳 대소문자 1글자 이상 20글자 이하의 문자열, 부피와 절박도는 1000 이하의 자연수입니다.

* ### 출력
#### &nbsp;각 테스트 케이스별 출력의 첫 줄에는 가져갈 수 있는 물건들의 최대 절박도 합과 가져갈 물건들의 개수를 출력합니다. 이후 한 줄에 하나씩 각 물건들의 이름을 출력합니다. 만약 절박도를 최대화하는 물건들의 조합이 여럿일 경우 아무 것이나 출력해도 좋습니다.

* ### 개인적 풀이
#### &nbsp;물건의 이름을 저장할 수 있는 string 배열 string object[100]을 만들고, 첫번째 값에 부피(int), 두번째 값에 절박도(int), 세번째 값에 인덱스(입력 순서대로)를 저장할 수 있는 volumeAndHope[100][3]배열을 만든다. 그리고 무게 오름차순으로 배열을 한다. 이 상태에서 [n][]번째 물건부터 부피가 꽉차기 전까지 넣어보고 최소 절박도를 구한다.

* ### 풀이

* ### 동적 계획법 알고리즘
#### &nbsp;물건을 가지고 가거나 안가지고 가거나 두가지 선택의 종류가 있으므로 2^n개의 조합이 있다. pack(items)는 지금까지 고른 물건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대 절박도의 합. 하지만 중요한 것은 마지막으로 고른 물건의 번호와 캐리어에 남아 있는 용량이다. pack(capacity, item)은 캐리어에 용량이 capacity만큼 남았을 때 item이후의 물건들을 싸서 얻을 수 있는 최대 절박도.
#### 01. 해당 물건을 가지고 가는 경우: pack(capacity - volume[item], item + 1) + need[item]
#### 02. 해당 물건을 가져가지 않는 경우: pack(capacity, item + 1)
```c++
int n, capacity;
int volume[100], need[100];
int cache[1001][100];
string name[100];
// 캐리어에 남은 용량이 capacity일 때, item이후의 물건들을 담아 얻을 수 있는 최대 절박도의 합을 반환
int pack(int capacity, int item) {
  // 기저 사례: 더 담을 물건이 없을 때
  if(item == n) return 0;
  int& ret = cache[capacity][item];
  if(ret != -1) return ret;
  // 이 물건을 담지 않을 경우
  ret = pack(capacity, item + 1);
  // 이 물건을 담을 경우
  if(capacity >= volume[item])
    ret = max(ret, pack(capacity - volume[item], item + 1) + need[item]);
  return ret;
}
```

* ### 시간 복잡도 분석
#### &nbsp;capacity인수는 [0, w]범위, item인수는 [0, n)범위의 값을 가지니 존재하는 부분 문제의 수는 O(nw)이다. 각 부분 문제 해결은 상수 시간이면 충분하기 때문에 전체 시간복잡도는 O(nw)다.

* ### 답 추적하기
#### &nbsp;각 부분 문제에 선택지가 두 개 밖에 없기 때문에 따로 선택을 저장하지 않고도 답을 역추적할 수 있다. pack(capacity, item)부분 문제에서 item을 선택 했는지 안했는지 알고 싶으면 pack(capacity, item + 1)과 pack(capacity, item)이 같은지 비교하면 된다.
```c++
// pack(capacity, item)이 선택한 물건들의 목록을 picked에 저장한다
void reconstrct(int capacity, int item, vector<string>& picked) {
  // 기저 사례
  if(item == n) return;
  if(pack(capacity, item) == pack(capacity, item + 1)) {
    reconstruct(capacity, item + 1, picked);
  } else {
    picked.push_back(name[item]);
    reconstruct(capacity - volume[item], item + 1, picked);
  }
}
```

## 09. 문제: 광학 문자 인식(문제 ID: OCR, 난이도: 상)
#### nbsp;광학 문자 인식(Optical Character Recognition)은 사람이 쓰거나 기계로 인쇄한 글자를 스캔한 이미지를 다시 기계가 읽을 수 있는 문자로 변환하는 과정을 말합니다. OCR 알고리즘들은 대개 수많은 필기 샘플을 통계적으로 분석하고 패턴을 찾아내어 각 단어들을 인식하곤 합니다. 하지만 단순히 각 단어들을 개별적으로 인식하기보다, 단어의 분포나 문법 등을 고려하면 더 나은 결과를 얻을 수 있는 경우가 많습니다. 이 문제에서는 과거 자료로부터 추출한 정보를 이용해 문자 인식의 정확도를 높여 봅시다. 과거에 인식했던 수많은 문장들을 분석해 원본 문장의 형태를 파악하려고 합니다. 이 작업을 위해 우선 과거 자료에 출현하는 모든 단어의 목록을 만든 뒤, 각 단어가 문장의 첫 단어로 사용된 비율을 계산했습니다. 그리고 각 단어 쌍에 대해, 한 단어가 다른 단어 다음에 출현할 확률을 계산했습니다. 이때 우리가 인식해야 할 원본 문장은 과거 자료와 똑같은 분포를 가진다고 가정합시다. 달리 말해 이 확률 테이블만 있으면 어떤 원본 문장이 출현할 확률을 정확히 계산할 수 있다고 가정한다는 얘깁니다. 우리의 문자 인식 알고리즘은 원문 그림을 여러 조각으로 쪼갠 후 각 조각을 비슷해 보이는 단어로 분류합니다. 이 분류하는 알고리즘을 분류기(classifier)라고 부릅니다. 이 분류기는 완벽하지 않기 때문에 특정 단어를 다른 단어로 잘 인식할 수도 있습니다. 예를 들어 boy라는 단어를 buy나 bay로 인식할 수 있다는 이야기입니다. 수많은 예제 입력에 대해 분류기를 시험하여, 각 단어가 적힌 조각을 분류기에 입력했을 때 어떤 출력을 얻을 수 있는지, 그리고 각각의 확률은 얼마였는지를 계산했습니다. 예를 들어 분류기에 실제 boy라고 씌어 있는 조각을 입력했을 때, 정확하게 boy로 인식할 확률은 0.7, bay일 확률은 0.25, buy일 확률은 0.04, bye일 확률은 0.01이었다는 식입니다. 이와 같은 정보들을 이용하면 좀더 나은 문자 인식을 할 수 있습니다. 각 조각을 앞에서 예로 든 분류기를 이용해 인식한 결과 "I am a bay."라는 문장을 결과로 얻었다고 합시다. 그런데 자료를 살펴보니 a 후에 bay가 올 확률은 얼마 없는 반면, a 후에 boy가 올 확률은 매우 컸다고 합시다. 우리의 분류기가 bay라고 인식한 조각이 사실은 boy일 확률이 0.25나 되기 때문에, 이 문장의 인식 결과를 "I am a boy."로 고치는 편이 더 올바른 분류일 것입니다. 어떤 문장을 단어별로 인식한 결과가 주어졌을 때, 원본일 조건부 확률이 가장 높은 문장을 찾아내는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 10초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### 01. 입력의 첫 줄에는 원문에 출현할 수 있는 단어의 수 m (1≤m≤500)과 처리해야 할 문장의 수 q (1≤q≤20)가 주어집니다.
#### 02. 두 번째 줄에는 원문에 출현할 수 있는 m개의 단어가 공백으로 구분되어 주어집니다. 각 단어는 알파벳 대소문자로만 구성되어 있습니다. 모든 단어의 길이는 10 이하입니다.
#### 03. 세 번째 줄에는 각 단어가 문장의 처음에 출현할 확률 B[i]가 m개의 실수로 주어집니다. B[i]는 i번 단어가 첫 단어로 출현할 확률입니다. 모든 B[i]의 합은 1입니다.
#### 04. 그 후 m줄에 m×m 크기의 실수 행렬 T가 주어집니다. 이 행렬에서 i행 j열의 숫자 T[i, j]는 i번 단어의 다음 단어가 j번 단어일 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.
#### 05. 그 후 m줄에 m×m 크기의 실수 행렬 M이 주어집니다. 이 행렬에서 i행 j열의 숫자 M[i, j]는 i번 단어가 적힌 조각을 j번 단어로 분류할 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.
#### 06. 그 후 q줄에 한 줄에 하나씩 분류기로 인식한 문장이 주어집니다. 각 줄의 처음에 단어의 수 n (1≤n≤100)이 주어지고, 그 후 n개의 단어로 분류기의 인식 결과가 주어집니다. 모든 단어는 처음에 주어진 m개의 단어 중 하나입니다.

* ### 출력
#### &nbsp;한 문장마다 한 줄에 주어진 인식 결과에 대해 조건부 출현 확률이 가장 높은 문장을 출력합니다. 주어지는 입력에서 가장 확률이 높은 문장이 여러 개인 경우 어느 것을 출력해도 좋습니다.

## 06. k번째 답 계산하기

* ### 예제: 모스 부호 사전(문제 ID: MORSE, 난이도: 중)
#### &nbsp;모스 부호(Morse code)는 전화가 없던 시절 무선 전신에 주로 사용하던 코드로, 짧은 신호(단점, o)와 긴 신호(장점, -)를 섞어 글자를 표현하는 표현방식입니다. 예를 들어 알파벳 J는 모스 부호 o---로 표현되고, M은 --로 표현됩니다. n개의 장점과 m개의 단점으로 구성된 모든 신호들을 담고 있는 사전이 있다고 합시다. 예를 들어 n = m = 2라면 다음과 같은 신호들이 포함되어 있는 것이죠. 이 신호들은 사전순서대로 정렬되어 있습니다. -의 아스키 코드는 45이고, o의 아스키 코드는 111이기 때문에 -가 먼저 오게 되죠. n과 m이 주어질 때 이 사전의 k번째 신호를 출력하는 프로그램을 작성해 봅시다. 예를 들어 위 사전에서 네 번째 신호는 o--o입니다.

* ### 개인적 풀이
#### &nbsp;각 자리에는 -혹은 o가 올 수 있다. 인자로 각각의 남은 -과 o의 개수를 넘겨주면 될 것 같다.
```c++
int cache[][];
vector<char> mosString;

int mos(int n, int m) {
  if(n != 0) {
    for(int numOfN = 0; numOfN < n; numOfN++) {
      mosString.push_back("-");
      mos(n - 1, m);
      mosString.pop_back();
    }
  }

  if(m != 0) {
    for(int numOfM = 0; numOfM < m; numOfM++) {
      mosString.push_back("o");
      mos(n, m - 1);
      mosString.pop_back();
    }
  }
}
```

* ### 모든 신호 만들기
#### &nbsp;완전 탐색 알고리즘은 매우 만들기 쉽다.
```c++
// s: 지금까지 만든 신호
// n: 더 필요한 -의 개수
// m: 더 필요한 o의 개수
void generate(int n, int m, string s) {
  // 지거 사례: n = m = 0
  if(n == 0 && m == 0) {
    cout << s << endl;
    return;
  }
  if(n > 0) generate(n - 1, m, s + "-");
  if(m > 0) generate(n, m - 1, s + "o");
}
```

* ### k - 1개 건너뛰기
#### &nbsp;신호가 완성될 때마다 이 신호를 건너뛰어야 하는지, 출력해야 하는지 결정한다.
```c++
int skip;
// skip개를 건너뛰고 출력한다.
void generate2(int n, int m, string s) {
  // 기저 사례: skip < 0;
  if(skip < 0) return;
  // 기저 사례: n = m = 0
  if(n == 0 && m == 0) {
    // 더 건너뛸 신호가 없는 겨우
    if(skip == 0) cout << s << endl;
    --skip;
    return;
  }
  if(n > 0) generate2(n - 1, m, s + "-");
  if(m > 0) generate2(n, m - 1, s + "o");
}
```
#### 이떄 전역변수 skip은 k - 1로 초기화 된다.

* ### 좀더 똑똑하게 건너뛰기
#### &nbsp;k가 크다면 시간안에 답을 찾을 수 없다. generate2(n, m, s)가 호출되면 이들을 조합해서 만들 수 있는 신호의 수는 이항계수로 나타낼 수 있다. skip이 이항 계수보다 크면 실행할 필요 없이 넘겨버리면 된다.
```c++
const int M = 1000000000 + 100;
int bino[201][201];
// 필요한 모든 이항계수를 미리 계산해 둔다
void calcBino() {
  memset(bino, 0, sizeof(bino));
  for(int i = 0; i <= 200; ++i) {
    bino[i][0] = bino[1][1] = 1;
    for(int j = 1; j < i; ++j)
      bino[i][j] = min(M, bino[i - 1][j - 1] + bino[i - 1][j]);
  }
}
// skip개를 건너뛰고 출력한다.
void generate3(int n, int m, string s) {
  // 기저 사례: skip < 0;
  if(skip < 0) return;
  // 기저 사례: n = m = 0
  if(n == 0 && m == 0) {
    // 더 건너뛸 신호가 없는 겨우
    if(skip == 0) cout << s << endl;
    --skip;
    return;
  }
  if(bino[n + m][n] < skip) {
    skip -= bino[n + m][n];
    return;
  }
  if(n > 0) generate3(n - 1, m, s + "-");
  if(m > 0) generate3(n, m - 1, s + "o");
}
```

* ### 좀더 깔끔한 구현
#### &nbsp;n개의 장점과 m개의 단점으로 구셩된 신호중 skip개를 건너뛰고 제일 먼저 오는 신호를 반환하는 함수 kth(n, m, skip)을 만들어 본다.
```c++
// n개의 -, m개의 o로 구성된 신호 중 skip개를 건너 뛰고 만들어지는 신호를 반환한다.
string kth(int n, int m, int skip) {
  // n == 0인 경우 나머지 부분은 전부 o일 수밖에 없다.
  if(n == 0) return string(m, 'o');
  if(skip < bino[n + m - 1][n - 1])
    return "-" + kth(n - 1, m, skip);
  return "o" + kth(n, m - 1, skip - bino[n + m - 1][n - 1]);
}
```

* ### k번째 답 계산하기 레시피
#### 1. 답들을 사전순서대로 만들며 경우의 수를 세는 완전 탐색 알고리즘을 설계하고, 메모이제이션을 적용해 경우의 수를 세는 동적 계획법 알고리즘으로 바꾼다.
#### 2. 모든 답들을 사전순으로 생성하며 skip개를 건너뛰고 첫 번쨰 답을 반환하는 재귀 호출 함수를 구현한다.

## 09. 문제: 드래곤 커브(문제 ID: DRAGON, 난이도: 중)
#### &nbsp;