9장 동적 계획법 테크닉
=====================
## 01. 최적화 문제의 실제 답 계산하기

* ### 예제: 최대 증가 부분 수열 실제로 출력하기
#### &nbsp;LIS가 실제 어떤 원소들로 구성되는지는 알 수가 없다. LIS를 구성하는 원소를 찾으려면 어떻게 해야하나? 실제 답을 계산하기 위해서는 각 부분 문제마다 어떤 선택지를 택했을 때 최적해를 얻는지를 기록해 두고, 별도의 재귀 함수를 이용해 각 조각에서 한 선택을 되짚어 가면서 최적해를 생성해 내면 된다.
```c++
int n;
int cache[101], s[100], choices[101];
// S[start]에서 시작하는 증가 부분 수열 중 최대 길이를 반환한다.
int lis4(int start) {
  int& ret = cache[start + 1];
  if(ret != -1) return ret;
  // 항상 S[start]는 있기 때문에 길이는 최하 1
  ret = 1;
  int bestNext = -1;
  for(int next = start + 1; next < n; ++next)
    if(start == -1 || S[start] < S[next]) {
      int cand = lis4(next) + 1;
      if(cand > ret) {
        ret = cand;
        bextNext = next;
      }
    }
  choices[start + 1] = bestNext;
  return ret;
}
// S[start]에서 시작하는 LIS를 seq에 저장한다.
void reconstruct(int start, vector<int>& seq) {
  if(start != -1) seq.push_back(S[start]);
  int next = choices[start + 1];
  if(next != -1) reconstruct(next, seq);
}
```

* ### 최적화 문제 답 계산하기 레시피
#### 01. 재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해둔다.
#### 02. 별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.

## 02. 문제: 여행 짐 싸기(문제 ID: PACKING, 난이도: 중)
#### &nbsp;여행을 떠나기 전날까지 절대 짐을 싸지 않는 버릇이 있는 재훈이는 오늘도 비행기 타기 전날에야 가방을 싸기 위해 자리에 앉았습니다. 비행기 규정상 재훈이는 캐리어를 하나만 가지고 갈 수 있는데, 아무래도 가져가고 싶은 물건들이 캐리어 안에 다 들어가지 않을 것 같습니다. 재훈이는 가져가고 싶은 각 물건들의 부피와 얼마나 필요한지를 나타내는 절박도를 조사해 다음과 같은 목록을 만들었습니다. 캐리어의 용량이 정해져 있기 때문에 가져갈 수 있는 물건들의 부피 합은 캐리어의 용량 w 이하여야 합니다. 이때 절박도를 최대화할 수 있는 물건들의 목록을 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야만 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (1≤C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 가져가고 싶은 물건의 수 N (1≤N≤100)과 캐리어의 용량 W (1≤W≤1000)가 주어집니다. 그 이후 N줄에 순서대로 각 물건의 정보가 주어집니다. 한 물건에 대한 정보는 물건의 이름, 부피, 절박도 순서대로 주어지며, 이름은 공백 없는 알파벳 대소문자 1글자 이상 20글자 이하의 문자열, 부피와 절박도는 1000 이하의 자연수입니다.

* ### 출력
#### &nbsp;각 테스트 케이스별 출력의 첫 줄에는 가져갈 수 있는 물건들의 최대 절박도 합과 가져갈 물건들의 개수를 출력합니다. 이후 한 줄에 하나씩 각 물건들의 이름을 출력합니다. 만약 절박도를 최대화하는 물건들의 조합이 여럿일 경우 아무 것이나 출력해도 좋습니다.

* ### 개인적 풀이
#### &nbsp;물건의 이름을 저장할 수 있는 string 배열 string object[100]을 만들고, 첫번째 값에 부피(int), 두번째 값에 절박도(int), 세번째 값에 인덱스(입력 순서대로)를 저장할 수 있는 volumeAndHope[100][3]배열을 만든다. 그리고 무게 오름차순으로 배열을 한다. 이 상태에서 [n][]번째 물건부터 부피가 꽉차기 전까지 넣어보고 최소 절박도를 구한다.

* ### 풀이

* ### 동적 계획법 알고리즘
#### &nbsp;물건을 가지고 가거나 안가지고 가거나 두가지 선택의 종류가 있으므로 2^n개의 조합이 있다. pack(items)는 지금까지 고른 물건들의 목록이 items에 주어질 때, 남은 용량을 채워 얻을 수 있는 최대 절박도의 합. 하지만 중요한 것은 마지막으로 고른 물건의 번호와 캐리어에 남아 있는 용량이다. pack(capacity, item)은 캐리어에 용량이 capacity만큼 남았을 때 item이후의 물건들을 싸서 얻을 수 있는 최대 절박도.
#### 01. 해당 물건을 가지고 가는 경우: pack(capacity - volume[item], item + 1) + need[item]
#### 02. 해당 물건을 가져가지 않는 경우: pack(capacity, item + 1)
```c++
int n, capacity;
int volume[100], need[100];
int cache[1001][100];
string name[100];
// 캐리어에 남은 용량이 capacity일 때, item이후의 물건들을 담아 얻을 수 있는 최대 절박도의 합을 반환
int pack(int capacity, int item) {
  // 기저 사례: 더 담을 물건이 없을 때
  if(item == n) return 0;
  int& ret = cache[capacity][item];
  if(ret != -1) return ret;
  // 이 물건을 담지 않을 경우
  ret = pack(capacity, item + 1);
  // 이 물건을 담을 경우
  if(capacity >= volume[item])
    ret = max(ret, pack(capacity - volume[item], item + 1) + need[item]);
  return ret;
}
```

* ### 시간 복잡도 분석
#### &nbsp;capacity인수는 [0, w]범위, item인수는 [0, n)범위의 값을 가지니 존재하는 부분 문제의 수는 O(nw)이다. 각 부분 문제 해결은 상수 시간이면 충분하기 때문에 전체 시간복잡도는 O(nw)다.

* ### 답 추적하기
#### &nbsp;각 부분 문제에 선택지가 두 개 밖에 없기 때문에 따로 선택을 저장하지 않고도 답을 역추적할 수 있다. pack(capacity, item)부분 문제에서 item을 선택 했는지 안했는지 알고 싶으면 pack(capacity, item + 1)과 pack(capacity, item)이 같은지 비교하면 된다.
```c++
// pack(capacity, item)이 선택한 물건들의 목록을 picked에 저장한다
void reconstrct(int capacity, int item, vector<string>& picked) {
  // 기저 사례
  if(item == n) return;
  if(pack(capacity, item) == pack(capacity, item + 1)) {
    reconstruct(capacity, item + 1, picked);
  } else {
    picked.push_back(name[item]);
    reconstruct(capacity - volume[item], item + 1, picked);
  }
}
```

## 09. 문제: 광학 문자 인식(문제 ID: OCR, 난이도: 상)
#### nbsp;광학 문자 인식(Optical Character Recognition)은 사람이 쓰거나 기계로 인쇄한 글자를 스캔한 이미지를 다시 기계가 읽을 수 있는 문자로 변환하는 과정을 말합니다. OCR 알고리즘들은 대개 수많은 필기 샘플을 통계적으로 분석하고 패턴을 찾아내어 각 단어들을 인식하곤 합니다. 하지만 단순히 각 단어들을 개별적으로 인식하기보다, 단어의 분포나 문법 등을 고려하면 더 나은 결과를 얻을 수 있는 경우가 많습니다. 이 문제에서는 과거 자료로부터 추출한 정보를 이용해 문자 인식의 정확도를 높여 봅시다. 과거에 인식했던 수많은 문장들을 분석해 원본 문장의 형태를 파악하려고 합니다. 이 작업을 위해 우선 과거 자료에 출현하는 모든 단어의 목록을 만든 뒤, 각 단어가 문장의 첫 단어로 사용된 비율을 계산했습니다. 그리고 각 단어 쌍에 대해, 한 단어가 다른 단어 다음에 출현할 확률을 계산했습니다. 이때 우리가 인식해야 할 원본 문장은 과거 자료와 똑같은 분포를 가진다고 가정합시다. 달리 말해 이 확률 테이블만 있으면 어떤 원본 문장이 출현할 확률을 정확히 계산할 수 있다고 가정한다는 얘깁니다. 우리의 문자 인식 알고리즘은 원문 그림을 여러 조각으로 쪼갠 후 각 조각을 비슷해 보이는 단어로 분류합니다. 이 분류하는 알고리즘을 분류기(classifier)라고 부릅니다. 이 분류기는 완벽하지 않기 때문에 특정 단어를 다른 단어로 잘 인식할 수도 있습니다. 예를 들어 boy라는 단어를 buy나 bay로 인식할 수 있다는 이야기입니다. 수많은 예제 입력에 대해 분류기를 시험하여, 각 단어가 적힌 조각을 분류기에 입력했을 때 어떤 출력을 얻을 수 있는지, 그리고 각각의 확률은 얼마였는지를 계산했습니다. 예를 들어 분류기에 실제 boy라고 씌어 있는 조각을 입력했을 때, 정확하게 boy로 인식할 확률은 0.7, bay일 확률은 0.25, buy일 확률은 0.04, bye일 확률은 0.01이었다는 식입니다. 이와 같은 정보들을 이용하면 좀더 나은 문자 인식을 할 수 있습니다. 각 조각을 앞에서 예로 든 분류기를 이용해 인식한 결과 "I am a bay."라는 문장을 결과로 얻었다고 합시다. 그런데 자료를 살펴보니 a 후에 bay가 올 확률은 얼마 없는 반면, a 후에 boy가 올 확률은 매우 컸다고 합시다. 우리의 분류기가 bay라고 인식한 조각이 사실은 boy일 확률이 0.25나 되기 때문에, 이 문장의 인식 결과를 "I am a boy."로 고치는 편이 더 올바른 분류일 것입니다. 어떤 문장을 단어별로 인식한 결과가 주어졌을 때, 원본일 조건부 확률이 가장 높은 문장을 찾아내는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 10초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### 01. 입력의 첫 줄에는 원문에 출현할 수 있는 단어의 수 m (1≤m≤500)과 처리해야 할 문장의 수 q (1≤q≤20)가 주어집니다.
#### 02. 두 번째 줄에는 원문에 출현할 수 있는 m개의 단어가 공백으로 구분되어 주어집니다. 각 단어는 알파벳 대소문자로만 구성되어 있습니다. 모든 단어의 길이는 10 이하입니다.
#### 03. 세 번째 줄에는 각 단어가 문장의 처음에 출현할 확률 B[i]가 m개의 실수로 주어집니다. B[i]는 i번 단어가 첫 단어로 출현할 확률입니다. 모든 B[i]의 합은 1입니다.
#### 04. 그 후 m줄에 m×m 크기의 실수 행렬 T가 주어집니다. 이 행렬에서 i행 j열의 숫자 T[i, j]는 i번 단어의 다음 단어가 j번 단어일 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.
#### 05. 그 후 m줄에 m×m 크기의 실수 행렬 M이 주어집니다. 이 행렬에서 i행 j열의 숫자 M[i, j]는 i번 단어가 적힌 조각을 j번 단어로 분류할 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.
#### 06. 그 후 q줄에 한 줄에 하나씩 분류기로 인식한 문장이 주어집니다. 각 줄의 처음에 단어의 수 n (1≤n≤100)이 주어지고, 그 후 n개의 단어로 분류기의 인식 결과가 주어집니다. 모든 단어는 처음에 주어진 m개의 단어 중 하나입니다.

* ### 출력
#### &nbsp;한 문장마다 한 줄에 주어진 인식 결과에 대해 조건부 출현 확률이 가장 높은 문장을 출력합니다. 주어지는 입력에서 가장 확률이 높은 문장이 여러 개인 경우 어느 것을 출력해도 좋습니다.

## 06. k번째 답 계산하기

* ### 예제: 모스 부호 사전(문제 ID: MORSE, 난이도: 중)
#### &nbsp;모스 부호(Morse code)는 전화가 없던 시절 무선 전신에 주로 사용하던 코드로, 짧은 신호(단점, o)와 긴 신호(장점, -)를 섞어 글자를 표현하는 표현방식입니다. 예를 들어 알파벳 J는 모스 부호 o---로 표현되고, M은 --로 표현됩니다. n개의 장점과 m개의 단점으로 구성된 모든 신호들을 담고 있는 사전이 있다고 합시다. 예를 들어 n = m = 2라면 다음과 같은 신호들이 포함되어 있는 것이죠. 이 신호들은 사전순서대로 정렬되어 있습니다. -의 아스키 코드는 45이고, o의 아스키 코드는 111이기 때문에 -가 먼저 오게 되죠. n과 m이 주어질 때 이 사전의 k번째 신호를 출력하는 프로그램을 작성해 봅시다. 예를 들어 위 사전에서 네 번째 신호는 o--o입니다.

* ### 개인적 풀이
#### &nbsp;각 자리에는 -혹은 o가 올 수 있다. 인자로 각각의 남은 -과 o의 개수를 넘겨주면 될 것 같다.
```c++
int cache[][];
vector<char> mosString;

int mos(int n, int m) {
  if(n != 0) {
    for(int numOfN = 0; numOfN < n; numOfN++) {
      mosString.push_back("-");
      mos(n - 1, m);
      mosString.pop_back();
    }
  }

  if(m != 0) {
    for(int numOfM = 0; numOfM < m; numOfM++) {
      mosString.push_back("o");
      mos(n, m - 1);
      mosString.pop_back();
    }
  }
}
```

* ### 모든 신호 만들기
#### &nbsp;완전 탐색 알고리즘은 매우 만들기 쉽다.
```c++
// s: 지금까지 만든 신호
// n: 더 필요한 -의 개수
// m: 더 필요한 o의 개수
void generate(int n, int m, string s) {
  // 지거 사례: n = m = 0
  if(n == 0 && m == 0) {
    cout << s << endl;
    return;
  }
  if(n > 0) generate(n - 1, m, s + "-");
  if(m > 0) generate(n, m - 1, s + "o");
}
```

* ### k - 1개 건너뛰기
#### &nbsp;신호가 완성될 때마다 이 신호를 건너뛰어야 하는지, 출력해야 하는지 결정한다.
```c++
int skip;
// skip개를 건너뛰고 출력한다.
void generate2(int n, int m, string s) {
  // 기저 사례: skip < 0;
  if(skip < 0) return;
  // 기저 사례: n = m = 0
  if(n == 0 && m == 0) {
    // 더 건너뛸 신호가 없는 겨우
    if(skip == 0) cout << s << endl;
    --skip;
    return;
  }
  if(n > 0) generate2(n - 1, m, s + "-");
  if(m > 0) generate2(n, m - 1, s + "o");
}
```
#### 이떄 전역변수 skip은 k - 1로 초기화 된다.

* ### 좀더 똑똑하게 건너뛰기
#### &nbsp;k가 크다면 시간안에 답을 찾을 수 없다. generate2(n, m, s)가 호출되면 이들을 조합해서 만들 수 있는 신호의 수는 이항계수로 나타낼 수 있다. skip이 이항 계수보다 크면 실행할 필요 없이 넘겨버리면 된다.
```c++
const int M = 1000000000 + 100;
int bino[201][201];
// 필요한 모든 이항계수를 미리 계산해 둔다
void calcBino() {
  memset(bino, 0, sizeof(bino));
  for(int i = 0; i <= 200; ++i) {
    bino[i][0] = bino[1][1] = 1;
    for(int j = 1; j < i; ++j)
      bino[i][j] = min(M, bino[i - 1][j - 1] + bino[i - 1][j]);
  }
}
// skip개를 건너뛰고 출력한다.
void generate3(int n, int m, string s) {
  // 기저 사례: skip < 0;
  if(skip < 0) return;
  // 기저 사례: n = m = 0
  if(n == 0 && m == 0) {
    // 더 건너뛸 신호가 없는 겨우
    if(skip == 0) cout << s << endl;
    --skip;
    return;
  }
  if(bino[n + m][n] < skip) {
    skip -= bino[n + m][n];
    return;
  }
  if(n > 0) generate3(n - 1, m, s + "-");
  if(m > 0) generate3(n, m - 1, s + "o");
}
```

* ### 좀더 깔끔한 구현
#### &nbsp;n개의 장점과 m개의 단점으로 구셩된 신호중 skip개를 건너뛰고 제일 먼저 오는 신호를 반환하는 함수 kth(n, m, skip)을 만들어 본다.
```c++
// n개의 -, m개의 o로 구성된 신호 중 skip개를 건너 뛰고 만들어지는 신호를 반환한다.
string kth(int n, int m, int skip) {
  // n == 0인 경우 나머지 부분은 전부 o일 수밖에 없다.
  if(n == 0) return string(m, 'o');
  if(skip < bino[n + m - 1][n - 1])
    return "-" + kth(n - 1, m, skip);
  return "o" + kth(n, m - 1, skip - bino[n + m - 1][n - 1]);
}
```

* ### k번째 답 계산하기 레시피
#### 1. 답들을 사전순서대로 만들며 경우의 수를 세는 완전 탐색 알고리즘을 설계하고, 메모이제이션을 적용해 경우의 수를 세는 동적 계획법 알고리즘으로 바꾼다.
#### 2. 모든 답들을 사전순으로 생성하며 skip개를 건너뛰고 첫 번쨰 답을 반환하는 재귀 호출 함수를 구현한다.

## 09. 문제: 드래곤 커브(문제 ID: DRAGON, 난이도: 중)
#### &nbsp;드래곤 커브(Dragon curve)는 간단한 수학 규칙으로 그릴 수 있는 그림으로, 위 그림같은 형태를 지닙니다. 드래곤 커브는 선분 하나에서 시작해서 간단한 규칙으로 이 선분을 변형해서 만들어지며, 변형이 한 번 이루어져 세대가 변할 때마다 더욱 복잡한 모양으로 진화합니다. 이 도형같이 일부를 확대했을 때 전체와 비슷한 형태로 구성된 도형들을 프랙탈(fractal) 이라고 하지요. 드래곤 커브를 그리는 방법을 드래곤 커브 문자열이라고 부릅시다. 드래곤 커브 문자열은 X, Y, F, +, -로 구성된 문자열인데, 우리는 한 점에서 시작해 다음과 같이 커브를 그리면 됩니다.
#### F: 앞으로 한 칸 전진하며 선을 긋습니다.
#### +: 왼쪽으로 90도 회전합니다. 
#### -: 오른쪽으로 90도 회전합니다.
#### X, Y: 무시합니다.
#### 0세대 드래곤 커브를 그리는 문자열은 선분 하나인 FX 입니다. 그리고 그 이후의 다음 세대는 이전 세대 문자열의 각 글자를 다음과 같이 치환해서 만들어집니다.
#### X => X+YF
#### Y => FX-Y
#### n세대 드래곤 커브 문자열을 구하고 싶습니다. 이 때 문자열 전체를 구하면 너무 기니, 문자열 중 p번째 글자부터 l글자만을 계산하는 프로그램을 작성하세요.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 c (c <=50) 가 주어집니다. 각 테스트 케이스의 첫 줄에는 세 개의 정수로 드래곤 커브의 세대 n (0 <= n <= 50) , 그리고 p 와 l (1 <= p <= 1,000,000,000 , 1 <= l <= 50) 이 주어집니다. n세대의 드래곤 커브 문자열의 길이는 항상 p+l 이상이라고 가정해도 좋습니다.

* ### 출력
#### &nbsp;각 테스트케이스마다 한 줄에 n세대 드래곤 커브 문자열의 p번째 글자부터 l글자를 출력합니다.

* ### 개인적 풀이
#### &nbsp;X와 Y의 길이는 한세대 증가할 때 마다 1에서 4로 늘어난다. 따라서 n세대 증가 했을 때 길이는
#### 2 + (이전 세대 길이) * 2
#### 가 된다.

## 10. 풀이: 드래곤 커브

* ### 더 간단한 문제부터 풀어보자
#### &nbsp;이 문제를 n세대 드래곤 커브의 p번째 글자를 찾는 것으로 바꿔본다.

* ### p번째 글자를 찾는 함수 작성하기
#### &nbsp;curve(seed, generations)는 초기 문자열 sedd를 generations세대 진화시킨 결과를 출력한다.

* ### 계산 결과 길이 미리 계산하기
#### &nbsp;재귀 호출할 때마다 이 재귀 호출이 몇 글자를 출력할지를 미리 알고 skip과 이 값을 비교할 수 있어야 한다. length(n)은 2 + 2 * length(n - 1)이다.

* ### 구현하기
```c++
const int MAX = 1000000000 + 1;
// length[i] = X나 Y를 i번 치환한 후의 길이
int length[51];
void precalc() {
  length[0] = 1;
  for(int i = 1; i <= 50; ++i)
    length[i] = min(MAX, length[i - 1] * 2 + 2);
}
const string EXPAND_X = "X+YF";
const string EXPAND_Y = "FX-Y";
// dragonCurve를 generations 진화시킨 결과에서 skip번째 문자를 반환한다.
char expand(const string& dragonCurve, int generations, int skip) {
  // 기저 사례
  if(generations == 0) {
    assert(skip < dragonCurve.size());
    return dragonCurve[skip];
  }
  for(int i = 0; i < dragonCurve.size(); ++i)
    if(dragonCurve[i] == 'X' || dragonCurve[i] == 'Y') {
      if(skip >= length[generations])
        skip -= length[generations];
      else if(dragonCurve[i] == 'X')
        return expand(EXPAND_X, generations - 1, skip);
      else
        return expand(EXPAND_Y, generations - 1, skip);
    }
    // 확장되진 않지만 건너뛰어야 할 경우
    else if(skip > 0)
      --skip;
    // 답을 찾은 경우
    else
      return dragonCurve[i];
  return '#';
}
```

## 11. 정수 이외의 입력에 대한 메모이제이션
#### &nbsp;입력 중 하나가 정수가 아니라면 메모이제이션을 어떻게 적용할 수 있을까.

* ### 연관 배열 사용하기
#### &nbsp;map과 같은 연관 배열을 사용해 캐시를 구현할 수 있다.
```c++
map<vector<int>, int> cache;
```

* ### 일대일 대응 함수 작성하기
#### &nbsp;때때로 유용하게 써먹을 수 있는 방법은 입력을 적절하게 정수로 변환해 줄 수 있는 함수를 작성하는 것이다. 함수를 cache[]의 인덱스로 사용하는 법도 있다.

* ### 입력이 불린 값의 배열인 경우
#### &nbsp;종종 불린 값의 배열이 함수의 입력으로 주어지는 예를 볼 수 있다. 이때 길이가 n인 배열을 2진수로 나타내 십진수로 저장할 수 있다. 하지만 이 방법은 n이 굉장히 작을 때만 적용할 수 있다.

* ### 입력이 순열인 경우
#### &nbsp;가능한 n!개의 입력들 중 X가 사전순으로 몇 번째 오는지를 계산하는 함수를 만들면 쉽게 메모이제이션할 수 있다.

* ### 입력의 범위가 좁을 경우
#### &nbsp;만약 배열의 각 값이 [0, 9]에 속하면 n자리의 k진수로 생각해도 된다.

* ### 예제: 여행하는 외판원 문제
#### &nbsp;n!개의 경로를 모두 생성하는 완전 탐색 알고리즘은 매우 느리다.

* ### 함수의 정의 바꾸기
#### &nbsp;shortestPath()가 전체 경로의 길이 대신 남은 경로의 최소 길이만을 반환하도록 바꾼다. 또한 도시를 방문했는지 여부를 확인해야 하지만 어떤 순서로 방문했는지 알 필요가 없다. 따라서 shortestPath2(here, visited)는 현재 위치가 here이고 각 도시들을 방문한 적이 있는지의 여부가 불린 값 배열 visited에 주어질 때, here에서 시작해서 나머지 도시를 반문하는 부분 경로의 최소 길이를 반환하는 함수이다.

* ### 메모이제이션하기
#### &nbsp;길이가 정해져 있는 불린 값의 배열을 아예 정수형으로 표현하면 이 함수에 아주 쉽게 메모이제이션을 적용할 수 있다.

## 14. 문제: 실험 데이터 복구하기(문제 ID: RESTORE, 난이도: 중)
#### &nbsp;토요일에 출근해서 연구실에서 놀고 있던 대학원생 진호는 실수로 실험에 사용하던 데이터를 삭제하고 말았습니다. 복사본도 없는 터라 이대로라면 교수님의 진노를 한 몸에 받을 것은 자명한 일, 따라서 진호는 그럴 듯해 보이는 데이터를 위조하여 교수님의 분노를 피해 가기로 합니다. 우리가 데이터에 대해 알고있는 것은, 데이터가 k개의 문자열 조각을 부분 문자열로 포함하며, 모두 알파벳 소문자로 구성된다는 사실 밖에 없습니다. (어떤 문자열의 부분 문자열은 해당 문자열의 연속된 일부분입니다.) 주어진 문자열 조각들을 모두 부분 문자열로 포함하는 문자열 중 가장 짧은 것을 계산하는 프로그램을 작성하세요. 만약 이와 같은 문자열이 여럿이라면 아무 문자열이나 출력하면 됩니다.

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 2초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C(C≤50)가 주어집니다. 각 테스트 케이스의 첫 줄에는 부분 문자열의 수 k(1≤k≤15)가 주어지고, 다음 k줄에 알파벳 소문자로만 구성된 문자열 조각이 주어집니다. 각 문자열 조각의 길이는 1 이상 40 이하입니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 한 줄로, 해당 문자열을 모두 포함하는 가장 짧은 문자열 중 하나를 출력합니다.

* ### 개인적 풀이
#### &nbsp;일단 완전탐색 풀이법으로는 하나의 단어를 선택해서 모든 경우의 수의 배열을 만들어 보면 된다. 하지만 부분 문자열의 수는 최대 15개다. 이렇게 모든 경우의 수를 계산해 보면 15!이라는 엄청 큰 수가 나오게 된다.

## 15. 풀이: 실험 데이터 복구하기

* ### 답의 구조 파악하기
#### 1. 어떤 문자열 조각에도 포함되지 않는 문자를 더할 일은 절대 없다.
#### 2. 연속해서 출현하는 문자열들의 접미사와 접두사를 최대한 많이 겹치게 해야 가장 짧은 문자열을 찾을 수 있다.
#### 3. 한 문자열 조각이 다른 문자열에 포함될 경우 무시하면 된다.

* ### 모든 답을 만들어 보기
#### &nbps;문자열을 만드는 좋은 방법은 문자열 조각들이 어떤 순서대로 출현할지를 정하는 것이다.

* ### 비슷한 문제를 풀어 본 적이 있군요
#### &nbsp;restore(last, used)는 마지막에 출현한 조각 last와 지금까지 출현한 조각의 집합 used가 주어질 때, 나머지 조각을 추가해서 얻을 수 있는 overlaps()의 최대 합.

* ### 최적해의 점수 계산하기
```c++
const int MAX_N = 15;
int k;
string word[MAX_N];
int cache[MAX_N][1<<MAX_N], overlap[MAX_N][MAX_N];
int restore(int last, int used) {
  // 기저 사례
  if(used == (1<<k) - 1) return 0;
  // 메모이제이션
  int& ret = cache[last][used];
  if(ret != -1) return ret;
  ret = 0;
  for(int next = 0; next < k; ++next)
    if((used & (1<<next)) == 0) {
      int cand = overlap[last][next] + resotre(next, used + (1<<next));
      ret = max(ret, cand);
    }
  return ret;
}
```

## 16. 조합 게임
#### &nbsp;동적 계획법의 또 다른 사용처는 여러 조합 게임을 해결하는 것이다.

* ### 게임 트리
#### &nbsp;게임 트리를 이용해 완벽한 수의 개념을 이해할 수 있다.

* ### 위에서 내려가기
#### &nbsp;게임트리를 흔히 위에서부터 내려오는 재귀 호출 알고리즘을 이용해서 구현한다. winner(state, player)는 게임의 현재 상태가  state이고, player가 수를 둘 차례일 때 어느 쪽이 최종적으로 이길까를 의미한다. 유의할 점은 어느 쪽이 수를 둘 차례인지를 player인자를 통해 따로 전달한다는 것이다. 하지만 다음과 같이 정의를 바꾸면 player와 같은 정보가 필요 없도록 할 수 있다. canWin(state)는 게임의 현재 상태가 state일 때, 이번에 수를 둘 차례인 참가자가 이길까를 의미한다.

* ### 메모이제이션
#### &nbsp;오목과 같은 게임은 한 상태를 굉장히 여러 가지 방법으로 얻을 수 있다. 따라서 이런 경우 메모이제이션이 사용가능하다.

* ### 그럼 바둑이나 체스는?
#### &nbsp;매우매우 오래 걸림.

* ### 처음으로 돌아올 수 있는 게임들
#### &nbsp;한 번 둔 수를 다시 물릴 수 있는 게임에서는 지난 상태로 다시 돌아갈 수 있기 때문에 게임 트리에 사이클이 생길 수 있고, 따라서 지금까지 설명한 대로 쉽게 문제를 풀 수 없다.

* ### 예제: 틱택토(문제 ID: TICTACTOE, 난이도: 하)
#### &nbsp;틱택토는 3x3 크기의 게임판에서 하는 3목 게임입니다. 두 명이 번갈아가며 o와 x를 게임판의 빈 칸에 쓰되, 먼저 같은 글자를 가로, 세로 혹은 대각선으로 3개 쓰이도록 하는 쪽이 이깁니다. 예를 들어, 다음 게임판은 x가 이긴 게임판입니다. 게임은 항상 x부터 시작합니다. 틱택토 게임판의 현재 상태가 주어집니다. 두 사람 모두 최선을 다한다고 가정할 때, 어느쪽이 이길지 판단하는 프로그램을 작성하세요.

* ### 상태 표현
#### &nbsp;canWin(board)는 틱택톡 게임판이 현재 board일 때 이번 차례인 사람이 이길 수 있는지 반환한다. 일대일 함수를 구현하는 간단한 방법은 board를 아홉자리의 3진수 숫자로 보는 것이다.

* ### 비기는 게임
#### &nbps;틱택톡 게임에서는 다음과 같은 세가지 상황이 있다.
#### 01. 이번 차례인 참가자가 이길 수 있는 경우
#### 02. 이길 수는 없지만 최선을 다하면 비길 수 있는 경우
#### 03. 최선을 다해도 상대가 실수하지 않으면 항상 질 수밖에 없는 경우
#### canWin()의 정의를 게임판이 board일 때 이번 차례인 사람이 이길 수 있으면 1을, 비길 수 있으면 0을, 질 수밖에 없으면 -1을 반환하는 함수로 바꾼다.

* ### 구현
```c++
// turn이 한 줄을 만들었는지를 반환한다. 
bool isFinished (const vector<string>& board, char turn)
// 틱택토 게임판이 주어질 때 [0,19682] 범위의 정수로 변환한다.
int bijection (const vector<string>& board) {
  int ret = 0;
  for (int y = 0; y < 3; y++)
    for (int x = 0; x < 3; x++) {
      ret = ret * 3;
      if(board[y][x] == 'o') ++ret;
      else if (board[y][x] == 'x') ret += 2;
  }
  return ret;
}
// cache[]는 -2로 초기화한다.
int cache[19683];
// 내가 이길 수 있으면 1을 비길 수 있으면 0을 지면 -1을 리턴한다.
int canWin (vector<string>& board, char turn) {
  // base case : 마지막에 상대가 둬서 한 줄이 만들어진 경우 
  if (isFinished(board, 'o' + 'x' - turn)) return -1;
  int& ret = &cache[bijection(board)];
  if (ret != -2) return ret;
  // 모든 반환 값의 min을 취하자.
  int minValue = 2;
  for (int y = 0; y < 3; y++)
    for (int x = 0; x < 3; x++)
      if (board[y][x] == '.') {
        board[y][x] = turn;
        minValue = min(minValue,canWin(board,'o'+'x'-turn));
        board[y][x] = '.';
      }
  // 플레이 ㅎ할 수 없거나, 어떻게 해도 비기는 것이 최선인 경우 
  if (minValue == 2 || minValue == 0) return ret = 0;
  // 최선이 상대가 이기는 거라면 난 무조건 지고, 상대가 지는 거라면 난 이긴다.
  return ret = -minValue;
}
```

* ### 더 빠르게 구현하기
#### &nbsp;다른 문제에서 상태의 수가 너무 클 경우 게임판을 뒤집거나 회전 시켜서 중복을 제거할 수 있다.

* ### 무조건 비기기
#### &nbsp;틱택토는 양쪽이 완벽하게 플레이할 경우 항상 비길 수밖에 없음을 알 수 있다.

## 17. 문제: 숫자 게임(문제 ID: NUMBERGAME, 난이도: 하)
#### &nbsp;n개의 정수를 일렬로 늘어놓은 게임판을 가지고 현우와 서하가 게임을 합니다. 게임은 현우부터 시작해서 번갈아가며 진행하며, 각 참가자는 자기 차례마다 두 가지 일 중 하나를 할 수 있습니다.
#### 01. 게임판의 왼쪽 끝에 있는 숫자나 오른쪽 끝에 있는 숫자 중 하나를 택해 가져갑니다. 가져간 숫자는 게임판에서 지워집니다.
#### 02. 게임판에 두 개 이상의 숫자가 있을 경우, 왼쪽 끝에서 2개, 혹은 오른쪽 끝에서 2개를 지웁니다.
#### 게임은 모든 숫자가 다 없어졌을 때 끝나며, 각 사람의 점수는 자신이 가져간 숫자들의 합입니다. 현우와 서하는 점수가 더 낮은 쪽이 점수 높은 쪽에 한 점 차이마다 백 원씩 주기로 내기를 했습니다. 두 사람 모두 최선을 다할 때, 두 사람의 최종 점수 차이는 얼마일까요?

* ### 시간 및 메모리 제한
#### &nbsp;프로그램은 1초 안에 실행되어야 하며, 64MB 이하의 메모리를 사용해야 한다.

* ### 입력
#### &nbsp;입력의 첫 줄에는 테스트 케이스의 수 C (C <= 50) 이 주어집니다. 각 테스트 케이스의 첫 줄에는 게임판의 길이 n (1 <= n <= 50) 이 주어지며, 그 다음 줄에 n 개의 정수로 게임판의 숫자들이 순서대로 주어집니다. 각 숫자는 -1,000 에서 1,000 사이의 정수입니다.

* ### 출력
#### &nbsp;각 테스트 케이스마다 한 줄로, 두 사람이 최선을 다했을 때 현우가 서하보다 몇 점 더 얻을 수 있는지를 출력합니다.

* ### 개인적 풀이
#### &nbsp;