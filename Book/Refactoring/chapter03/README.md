# 코드에서 나는 악취

&nbsp;리팩터링을 언제 시작하고 언제 그만할지 판단하는 것은 중요하다. 그리고 리팩터링이 필요한 코드들에는 일정한 패턴이 있다.

## 기이한 이름(Mysterious Name)

&nbsp;코드는 단순하고 명료하게 작성해야 한다. 그리고 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.

## 중복 코드(Duplicated Code)

&nbsp;똑같은 코드 구조를 통합해서 더 나은 프로그램을 만들 수 있다.

## 긴 함수(Long Function)

&nbsp;`간접 호출`의 효과는 함수를 짧게 구성할 때 나오는 것이다. 또한 함수 이름을 잘 지어두면 함수 본문을 볼 필요가 없다. 그러기 위해서는 함수를 적극적으로 쪼개야 한다.

## 긴 매개변수 목록(Long Parameter List)

&nbsp;매개변수 목록이 길어지면 이해하기 어려울 때가 많다. 따라서 여러 방법을 이용해서 줄이도록 하자.

## 전역 데이터(Global Data)

&nbsp;전역 데이터는 버그 발생시 원인이 되는 코드를 찾아내기 어렵게 만든다. 다른 코드를 오염시킬 가능성이 있는 변수를 찾아서 접근을 통제한다. 전역데이터가 조금이라도 있으면 캡슐화하는 편이 좋다.

## 가변 데이터(Mutable Data)

&nbsp;데이터 변경은 예상치 못한 결과나 버그로 이어지는 경우가 종종 있다. 그래서 함수형 프로그래밍을 사용한다. 하지만 데이터 수정에 따른 위험을 줄이는 방법은 얼마든지 있다.

## 뒤엉킨 변경(Divergent Change)

&nbsp;코드를 수정할 때 한 군데를 찾아서 수정하는 것으로 해결할 수 없다면 뒤엉킨 변경일 수도 있다. 뒤엉킨 변경은 SRP가 지켜지지 않을 때 나타난다.

## 산탄총 수술(Shotgun Surgery)

&nbsp;산탄총 수술은 뒤엉킨 변경과 비슷하면서도 정반대다. 자잘하게 수정해야하는 클래스가 많을 때 풍긴다. 어설프게 분리된 로직을 하나로 합치는 것도 좋은 방법이다.

## 기능 편애(Feature Envy)

&nbsp;기능 편애는 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다. 이는 전략 패턴이나 방문자 패턴을 이용해서도 해결할 수 있다.

## 데이터 뭉치(Data Clumps)

&nbsp;
